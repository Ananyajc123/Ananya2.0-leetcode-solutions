Problem 1: Build Array from Permutation (LeetCode #1920)
Difficulty: Easy
Link: https://leetcode.com/problems/build-array-from-permutation/
Topics: Array, Simulation
Problem Statement
Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.
A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).
Example 1:
Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]

Explanation: 
The array ans is built as follows: 
ans[0] = nums[nums[0]] = nums[0] = 0
ans[1] = nums[nums[1]] = nums[2] = 1
ans[2] = nums[nums[2]] = nums[1] = 2
ans[3] = nums[nums[3]] = nums[5] = 4
ans[4] = nums[nums[4]] = nums[3] = 5
ans[5] = nums[nums[5]] = nums[4] = 3
Example 2:
Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]

Explanation: 
The array ans is built as follows:
ans[0] = nums[nums[0]] = nums[5] = 4
ans[1] = nums[nums[1]] = nums[0] = 5
ans[2] = nums[nums[2]] = nums[1] = 0
ans[3] = nums[nums[3]] = nums[2] = 1
ans[4] = nums[nums[4]] = nums[3] = 2
ans[5] = nums[nums[5]] = nums[4] = 3
Constraints:

1 <= nums.length <= 1000
0 <= nums[i] < nums.length
The elements in nums are distinct.


Visual Understanding
Let's visualize Example 1:
Original Array (nums):
Index:  0  1  2  3  4  5
Value:  0  2  1  5  3  4

Building ans array:
ans[0] = nums[nums[0]] = nums[0] = 0
         ↓     ↓           ↓
       use 0  get 0    value at index 0 is 0

ans[1] = nums[nums[1]] = nums[2] = 1
         ↓     ↓           ↓
       use 1  get 2    value at index 2 is 1

ans[2] = nums[nums[2]] = nums[1] = 2
         ↓     ↓           ↓
       use 2  get 1    value at index 1 is 2

ans[3] = nums[nums[3]] = nums[5] = 4
         ↓     ↓           ↓
       use 3  get 5    value at index 5 is 4

ans[4] = nums[nums[4]] = nums[3] = 5
         ↓     ↓           ↓
       use 4  get 3    value at index 3 is 5

ans[5] = nums[nums[5]] = nums[4] = 3
         ↓     ↓           ↓
       use 5  get 4    value at index 4 is 3

Result Array (ans):
Index:  0  1  2  3  4  5
Value:  0  1  2  4  5  3
Key Insight: We use the value at each index as a new index to get the final value!

Solution
javaclass Solution {
    public int[] buildArray(int[] nums) {
        // Create result array of same length
        int[] ans = new int[nums.length];
        
        // For each index i, set ans[i] = nums[nums[i]]
        for (int i = 0; i < nums.length; i++) {
            ans[i] = nums[nums[i]];
        }
        
        return ans;
    }
}

Line-by-Line Explanation
Line 1-2: Method Declaration
javaclass Solution {
    public int[] buildArray(int[] nums) {

public int[] → Returns an integer array
buildArray → Method name
int[] nums → Takes an integer array as input


Line 3: Create Result Array
javaint[] ans = new int[nums.length];

new int[nums.length] → Creates new array of same size as input
Initially filled with zeros: [0, 0, 0, 0, 0, 0]
ans → Variable to store our result

Why same length?

Each element in input produces exactly one element in output
One-to-one mapping


Line 5-7: Build Result Array
javafor (int i = 0; i < nums.length; i++) {
    ans[i] = nums[nums[i]];
}
Breaking down ans[i] = nums[nums[i]]:

Outer nums[i]: Get value at current index i
Inner nums[...]: Use that value as an index
Result: Store in ans[i]

Step-by-step for i = 1 with nums = [0,2,1,5,3,4]:
Step 1: i = 1
Step 2: nums[i] = nums[1] = 2 (get value at index 1)
Step 3: nums[nums[i]] = nums[2] = 1 (use 2 as index, get value)
Step 4: ans[1] = 1 (store result)

Line 9: Return Result
javareturn ans;

Return the newly built array


Complete Dry Run
Input: nums = [0,2,1,5,3,4]
Initial State:
nums = [0, 2, 1, 5, 3, 4]
ans  = [0, 0, 0, 0, 0, 0]  (initially all zeros)

Iteration i = 0:
├─ nums[i] = nums[0] = 0
├─ nums[nums[i]] = nums[0] = 0
├─ ans[0] = 0
└─ ans = [0, 0, 0, 0, 0, 0]

Iteration i = 1:
├─ nums[i] = nums[1] = 2
├─ nums[nums[i]] = nums[2] = 1
├─ ans[1] = 1
└─ ans = [0, 1, 0, 0, 0, 0]

Iteration i = 2:
├─ nums[i] = nums[2] = 1
├─ nums[nums[i]] = nums[1] = 2
├─ ans[2] = 2
└─ ans = [0, 1, 2, 0, 0, 0]

Iteration i = 3:
├─ nums[i] = nums[3] = 5
├─ nums[nums[i]] = nums[5] = 4
├─ ans[3] = 4
└─ ans = [0, 1, 2, 4, 0, 0]

Iteration i = 4:
├─ nums[i] = nums[4] = 3
├─ nums[nums[i]] = nums[3] = 5
├─ ans[4] = 5
└─ ans = [0, 1, 2, 4, 5, 0]

Iteration i = 5:
├─ nums[i] = nums[5] = 4
├─ nums[nums[i]] = nums[4] = 3
├─ ans[5] = 3
└─ ans = [0, 1, 2, 4, 5, 3]

Final Result: [0, 1, 2, 4, 5, 3] ✅

Complexity Analysis
Time Complexity: O(n)

We iterate through the array once
n = length of input array
Each iteration does O(1) work (array access and assignment)

Space Complexity: O(n)

We create a new array ans of size n
If we don't count output space, it's O(1) auxiliary space


Edge Cases
1. Single element:
Input: nums = [0]
Output: [0]
(nums[nums[0]] = nums[0] = 0)
2. Two elements:
Input: nums = [1,0]
Output: [0,1]
(ans[0] = nums[1] = 0, ans[1] = nums[0] = 1)
3. Identity permutation:
Input: nums = [0,1,2,3]
Output: [0,1,2,3]
(Each element points to itself)

Key Takeaways

Double indexing: nums[nums[i]] means "use value as index"
Array access is O(1): We can access any element directly
Permutation properties: Each index appears exactly once as a value
Simple simulation: Just follow the formula step by step