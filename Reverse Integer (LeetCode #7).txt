Problem 5: Reverse Integer (LeetCode #7)
Difficulty: Medium
Link: https://leetcode.com/problems/reverse-integer/
Topics: Math, While Loop, Overflow Handling
Problem Statement
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123
Output: 321
Example 2:
Input: x = -123
Output: -321
Example 3:
Input: x = 120
Output: 21
Constraints:

-2^31 <= x <= 2^31 - 1


Solution
javaclass Solution {
    public int reverse(int x) {
        int reversed = 0;
        
        while (x != 0) {
            // Extract last digit
            int digit = x % 10;
            x = x / 10;
            
            // Check for overflow BEFORE actually reversing
            // If reversed * 10 would overflow, return 0
            if (reversed > Integer.MAX_VALUE / 10 || 
                reversed < Integer.MIN_VALUE / 10) {
                return 0;
            }
            
            // Build reversed number
            reversed = reversed * 10 + digit;
        }
        
        return reversed;
    }
}

Explanation
Approach:

Initialize reversed to 0
Extract digits one by one from right to left using % 10 and / 10
Check for overflow BEFORE multiplying by 10
Build the reversed number
Return the result (or 0 if overflow detected)

Understanding Overflow:
Java int range:

Maximum: 2,147,483,647 (Integer.MAX_VALUE)
Minimum: -2,147,483,648 (Integer.MIN_VALUE)

If we try to go beyond this range, the number "wraps around" (overflow).
Why check reversed > Integer.MAX_VALUE / 10?
If reversed > Integer.MAX_VALUE / 10, then reversed * 10 will definitely overflow!
Example:
Integer.MAX_VALUE = 2,147,483,647
Integer.MAX_VALUE / 10 = 214,748,364

If reversed = 214,748,365 (which is > 214,748,364)
Then reversed * 10 = 2,147,483,650 > Integer.MAX_VALUE ❌ OVERFLOW!
Dry Run (x = 123):
Initial: x = 123, reversed = 0

Iteration 1:
  digit = 123 % 10 = 3
  x = 123 / 10 = 12
  Check overflow: 0 > 214748364? NO ✅
  reversed = 0 * 10 + 3 = 3

Iteration 2:
  digit = 12 % 10 = 2
  x = 12 / 10 = 1
  Check overflow: 3 > 214748364? NO ✅
  reversed = 3 * 10 + 2 = 32

Iteration 3:
  digit = 1 % 10 = 1
  x = 1 / 10 = 0
  Check overflow: 32 > 214748364? NO ✅
  reversed = 32 * 10 + 1 = 321

Loop exits (x = 0)
Return 321
Dry Run (x = -123):
Initial: x = -123, reversed = 0

Iteration 1:
  digit = -123 % 10 = -3 (in Java, % preserves sign)
  x = -123 / 10 = -12
  Check overflow: 0 < -214748364? NO ✅
  reversed = 0 * 10 + (-3) = -3

Iteration 2:
  digit = -12 % 10 = -2
  x = -12 / 10 = -1
  Check overflow: -3 < -214748364? NO ✅
  reversed = -3 * 10 + (-2) = -32

Iteration 3:
  digit = -1 % 10 = -1
  x = -1 / 10 = 0
  Check overflow: -32 < -214748364? NO ✅
  reversed = -32 * 10 + (-1) = -321

Loop exits (x = 0)
Return -321
Dry Run with Overflow (x = 1534236469):
After several iterations: reversed = 964632435

Next iteration:
  Check: 964632435 > 214748364? YES ❌
  Return 0 immediately (prevent overflow)
Important Note about Modulo with Negative Numbers in Java:
java-123 % 10 = -3 (not 7)
-123 / 10 = -12 (not -13)
Java preserves the sign in modulo operations, which makes our algorithm work for negative numbers automatically!
Time Complexity: O(log₁₀(n)) - Number of digits in the input
Space Complexity: O(1) - Only using a constant amount of space
Edge Cases:

x = 0: Returns 0 ✅
x = 120: Returns 21 (trailing zeros removed) ✅
x = 1534236469: Overflow → returns 0 ✅
x = -2147483648: Overflow when reversed → returns 0 ✅

Why not use String?
We could convert to string, reverse, and convert back:
java// This works but violates "don't use 64-bit" constraint
String str = String.valueOf(Math.abs(x));
String reversed = new StringBuilder(str).reverse().toString();